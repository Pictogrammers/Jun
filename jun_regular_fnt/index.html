<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitmap Font Preview</title>
    <style>
        :root {
            --app-font: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            --app-color: #E0E0E0;
        }
        body {
            display: grid;
            grid-template-columns: auto 1fr;
            grid-template-rows: auto 1fr;
            background: #262626;
            margin: 0;
            font-family: var(--app-font);
            height: 100vh;
            overscroll-behavior: none;
        }
        div.header {
            grid-column: 1;
            grid-row: 1;
            background: #3D3D3D;
            padding: 0.25rem 0.5rem;
            position: relative;
        }
        div.header::after {
            content: ' ';
            display: block;
            position: absolute;
            background: #495958;
            border-left: 0.125rem solid #2B2B2B;
            border-top: 0.125rem solid #2B2B2B;
            right: 0;
            bottom: 0;
            width: 0.25rem;
            height: 0.25rem;
            border-top-left-radius: 0.25rem;
        }
        div.header h1 {
            margin: 0;
            font-weight: normal;
            color: #FFF;
            font-size: 0.875rem;
        }
        div.header h1 span {
            font-weight: bold;
            text-shadow: 0 0 0.25rem black;
            margin-right: 0.25rem;
            font-size: 1.25rem;
        }
        div.links {
            display: grid;
            grid-template-columns: auto auto 1fr;
            grid-template-rows: auto;
            grid-column: 2;
            grid-row: 1;
            background: #3D3D3D;
            padding: 0.625rem 1rem 0.25rem 0.5rem;
            position: relative;
        }
        div.links::after {
            content: ' ';
            display: block;
            position: absolute;
            background: #495958;
            border-top: 0.125rem solid #2B2B2B;
            right: 0;
            left: 0;
            bottom: 0;
            height: 0.25rem;
        }
        div.links a {
            color: var(--app-color);
            background: #2B2B2B;
            text-decoration: none;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            align-self: start;
            display: flex;
            margin-top: -0.125rem;
        }
        div.links a:hover {
            background: #495958;
            color: #FFF;
        }
        div.links div.tab {
            align-self: end;
            z-index: 1;
            margin-right: 0.25rem;
        }
        div.links div.tab button {
            background: #2B2B2B;
            padding: 0.375rem 0.75rem 0.25rem 0.75rem;
            border-radius: 0.25rem 0.25rem 0 0;
            color: var(--app-color);
            display: flex;
            align-items: end;
            border: 0.125rem solid #2B2B2B;
        }
        div.links div.tab:not(.selected) button:hover {
            background: rgba(73, 89, 88, 0.5);
            border-bottom-color: rgba(73, 89, 88, 0.5);
        }
        div.links div.tab.selected button {
            background: #495958;
            border-bottom-color: #495958;
        }
        div.links div:last-child {
            display: flex;
            justify-content: end;
        }
        div.tree {
            display: grid;
            grid-column: 1;
            grid-row: 2;
            background: #3D3D3D;
            color: #DFDFDF;
            padding: 0 0.875rem 0.5rem 0.5rem;
            width: 12rem;
            position: relative;
        }
        div.tree::after {
            content: ' ';
            display: block;
            position: absolute;
            background: #495958;
            border-left: 0.125rem solid #2B2B2B;
            right: 0;
            top: 0;
            bottom: 0;
            width: 0.25rem;
        }
        div.tree > ul {
            margin: 0;
            padding: 0;
            list-style: none;
            display: grid;
            grid-template-columns: auto;
            grid-template-rows: auto auto auto auto 1fr;
        }
        div.tree > ul > li {
            display: flex;
            flex-direction: column;
        }
        div.tree > ul > li > div {
            padding: 0 0.5rem;
        }
        div.tree > ul > li ul {
            background: #2B2B2B;
            border-radius: 0.25rem;
            padding: 0.125rem;
            margin: 0.25rem 0;
            font-size: 0.875rem;
            list-style: none;
            display: flex;
            flex-direction: column;
            gap: 0.125rem;
        }
        div.tree > ul > li ul > li > button {
            width: 100%;
            padding: 0.25rem 0.5rem;
            border: 0;
            background: transparent;
            font: var(--app-font);
            color: var(--app-color);
            border-radius: 0.125rem;
            text-align: left;
        }
        div.tree > ul > li ul > li > button:hover {
            background: #495958;
        }
        div.tree > ul > li ul > li.selected {
            position: relative;
        }
        div.tree > ul > li ul > li.selected > button {
            background: #495958;
        }
        div.tree > ul > li ul > li.selected::after {
            content: ' ';
            width: 0.75rem;
            height: 0.25rem;
            top: calc(50% - 0.25rem);
            right: -0.75rem;
            display: block;
            position: absolute;
            background: #495958;
            border-bottom: 0.125rem solid #2B2B2B;
            border-top: 0.125rem solid #2B2B2B;
            z-index: 1;
        }
        div.tree > ul > li > button {
            border: 0.125rem solid #2B2B2B;
            border-radius: 0.25rem;
            background: #2B2B2B;
            color: var(--app-color);
            display: flex;
            align-items: center;
            margin-top: -0.375rem;
            margin-bottom: 0.25rem;
            padding: 0.25rem;
        }
        div.tree > ul > li > button:hover {
            color: var(--app-color);
            background: #495958;
        }
        div.tree > ul > li > button:active {
            box-shadow: 0 0.125rem 0.25rem rgba(0, 0, 0, 0.2) inset;
            text-shadow: 0 0.0625rem 0.125rem rgba(0, 0, 0, 0.25);
        }
        div.tree > ul > li > button svg {
            width: 1.5rem;
            height: 1.5rem;
            margin-right: 0.25rem;
        }
        li.appInfo {
            align-content: end;
            text-align: center;
            color: #AAA;
        }
        div.main {
            grid-column: 2;
            grid-row: 2;
            overflow: auto;
            background: #FFF;
            visibility: hidden;
        }
        #mainTabContent {
            display: grid;
            grid-template-columns: 0fr 1fr;
            grid-template-rows: auto;
            grid-gap: 0.5rem 1rem;
        }
        #kernTabContent .info {
            padding: 0.5rem 1rem;
            border-bottom: 1px solid #DDD;
        }
        div.main.selected {
            visibility: visible;
        }
        div.page {
            grid-column: 1;
            grid-row: 1;
            align-items: flex-start;
            justify-content: flex-start;
            display: inline-flex;
            position: relative;
            background: #FFF;
            border: 0.25rem solid rgba(73, 89, 88, 0.25);
            border-radius: 0.25rem 0.25rem 0 0.25rem;
            margin: 1rem 0 1rem 1rem
        }
        div.page > img {
            image-rendering: pixelated;
        }
        div.page > div {
            position: absolute;
            background: rgba(255, 0, 0, 0.3);
            box-sizing: border-box;
        }
        div.page > div:hover {
            background: rgba(33, 150, 243, 0.3);
        }
        div.page > span {
            position: absolute;
            bottom: calc(-0.5rem + -1rem + -0.125rem);
            right: -0.25rem;
            white-space: nowrap;
            background: rgba(73, 89, 88, 0.25);
            border-radius: 0 0 0.25rem 0.25rem;
            padding: 0.125rem 0.25rem;
            font-size: 0.875rem;
            color: #FFF;
        }
        div.preview {
            grid-column: 1;
            grid-row: 3;
            display: flex;
            background: #FFF;
            border: 0.25rem solid rgba(73, 89, 88, 0.25);
            border-radius: 0.25rem;
            flex-wrap: wrap;
            margin-left: 1rem;
        }
        div.break {
            width: 100%;
        }
        canvas {
            image-rendering: pixelated;
        }
        canvas.hover {
            background: #c6ebff;
        }
        canvas.hover-exists {
            background: #8de558;;
        }
        div.preview > canvas:first-child {
            margin-left: 0 !important;
        }
        /**
         * Documentation
         */
        div.doc {
            grid-column: 1;
            grid-row: 4;
            position: relative;
            color: #333;
            padding: 0.5rem;
            background: rgba(73, 89, 88, 0.05);
            border: 0.25rem solid rgba(73, 89, 88, 0.25);
            border-radius: 0.25rem 1.5rem 0.25rem 0.25rem;
            margin-left: 1rem;
        }
        div.doc::before {
            content: ' ';
            position: absolute;
            width: 1.25rem;
            height: 1.25rem;
            top: 0;
            right: 0;
            border-bottom: 0.25rem solid rgba(73, 89, 88, 0.25);
            border-left: 0.25rem solid rgba(73, 89, 88, 0.25);
            border-bottom-left-radius: 1rem;
            background: rgba(73, 89, 88, 0.1);
            background-clip: content-box;
            border-top-right-radius: 1.25rem;
        }
        div.doc h2 {
            margin: 0.5rem 0 0.25rem 0;
            font-size: 1.125rem;
        }
        div.doc p {
            margin: 0;
        }
        div.doc ul {
            margin: 0.5rem 0;
        }
        textarea {
            grid-column: 1;
            grid-row: 2;
            border: 0.25rem solid rgba(73, 89, 88, 0.5);
            border-radius: 0.25rem;
            resize: none;
            height: 3rem;
            padding: 0.5rem;
            margin-left: 1rem;
        }
        textarea:focus {
            border: 0.25rem solid rgba(73, 89, 88, 1);
            outline: none;
        }
        div.kernings {
            grid-column: 2;
            grid-row: 1 / 6;
            overflow: auto;
            padding: 1rem 0;
        }
        table {
            border-spacing: 0;
            max-width: 15rem;
            border: 0.25rem solid rgba(73, 89, 88, 0.25);
            border-radius: 0.25rem;
        }
        table th {
            padding-right: 0.5rem;
            font-size: 0.875rem;
        }
        table tr:nth-child(odd) {
            background-color: #EEE;
        }
        table tr:nth-child(1) {
            background-color: #FFF;
        }
        table tr:nth-child(1) th {
            border-bottom: 1px solid #DDD;
            text-align: left;
        }
        table tr th,
        table tr td {
            padding: 0 0.25rem;
        }
        /**
         * Toast
         */
        .toast {
            position: absolute;
            padding: 0.75rem 1rem;
            background: #EEE;
            top: 1rem;
            right: 1rem;
            box-shadow: 0 0.25rem 1rem rgba(0, 0, 0, 0.25);
            border-radius: 0.5rem;
        }
        .toast-info {
            color: #fff;
            font-weight: 500;
            background-color: #2196f3;
        }
        .toast-warning {
            color: #fff;
            font-weight: 500;
            background-color: #ff9800;
        }
        .toast-error {
            color: #fff;
            font-weight: 500;
            background-color: #f44336;
        }
        .toast-success {
            color: #fff;
            font-weight: 500;
            background-color: #4caf50;
        }
        /**
         * Info / Common
         */
        ul.common,
        ul.info {
            display: flex;
            gap: 0.125rem;
            flex-direction: column;
        }
        li.row {
            display: flex;
            flex-direction: row;
            gap: 0.125rem;
        }
        li.row div {
            padding: 0.125rem 0.5rem;
            background: #3D3D3D;
            line-height: 1rem;
        }
        li.row div:first-child {
            background: rgba(61, 61, 61, 0.5);
            border-top-left-radius: 0.125rem;
            border-bottom-left-radius: 0.125rem;
            color: #BBB;
        }
        li.row div:last-child {
            border-top-right-radius: 0.125rem;
            border-bottom-right-radius: 0.125rem;
            padding: 0.125rem 0.5rem;
        }
    </style>
    <script>
        // Cache Configs
        const file = 'jun_regular.json';
        const characters = new Map();
        const pages = new Map();
        const pageIndexByName = new Map();
        const imagePages = new Map();
        const info = new Map();
        const kernings = new Map();
        // Utilities
        function addPage(name) {
            const pagesElement = document.getElementById('pages');
            const item = document.createElement('li');
            const button = document.createElement('button');
            button.textContent = name;
            item.appendChild(button);
            pagesElement.appendChild(item);
            item.addEventListener('click', () => {
                selectPage(name);
            });
        }
        function selectPage(name) {
            const pagesElement = document.getElementById('pages');
            const items = [...pagesElement.querySelectorAll('li')];
            const pageEles = [...document.querySelectorAll('.page')];
            items.forEach((item, index) => {
                item.classList.toggle('selected', item.textContent === name);
                pageEles[index].style.order = item.textContent === name ? 2 : 1;
            });
            // Remember page
            localStorage.setItem(file, name);
        }
        function addInfo(label, value, title) {
            const row = document.createElement('li');
            row.classList.add('row');
            const labelEle = document.createElement('div');
            labelEle.textContent = label;
            labelEle.title = title;
            row.appendChild(labelEle);
            if (value instanceof Array) {
                value.forEach(item => {
                    const valueEle = document.createElement('div');
                    valueEle.textContent = item.value;
                    valueEle.title = item.label;
                    row.appendChild(valueEle);
                });
            } else {
                const valueEle = document.createElement('div');
                valueEle.textContent = value;
                row.appendChild(valueEle);
            }
            return row;
        }
        const infoDictionary = {
            face: 'This is the name of the true type font.',
            size: 'The size of the true type font.',
            bold: 'The font is bold.',
            italic: 'The font is italic.',
            charset: 'The name of the OEM charset used (when not unicode).',
            unicode: 'Set to 1 if it is the unicode charset.',
            stretchH: 'The font height stretch in percentage. 100% means no stretch.',
            smooth: 'Set to 1 if smoothing was turned on.',
            aa: 'The supersampling level used. 1 means no supersampling was used.',
            padding: 'The padding for each character (up, right, down, left).',
            spacing: 'The spacing for each character (horizontal, vertical).',
            outline: 'The outline thickness for the characters.'
        };
        function updateInfo(data) {
            const infoElement = document.getElementById('info');
            const nameEle = addInfo('face', data.info.face, infoDictionary.face);
            infoElement.appendChild(nameEle);
            const sizeEle = addInfo('size', data.info.size, infoDictionary.size);
            infoElement.appendChild(sizeEle);
            const italicEle = addInfo('italic', data.info.italic, infoDictionary.italic);
            infoElement.appendChild(italicEle);
            const boldEle = addInfo('bold', data.info.bold, infoDictionary.bold);
            infoElement.appendChild(boldEle);
            const paddingEle = addInfo('padding', [
                { label: 'Top', value: data.info.padding[0] },
                { label: 'Right', value: data.info.padding[1] },
                { label: 'Bottom', value: data.info.padding[2] },
                { label: 'Left', value: data.info.padding[3] }
            ], infoDictionary.padding);
            infoElement.appendChild(paddingEle);
            const spacingEle = addInfo('spacing', [
                { label: 'Horizontal', value: data.info.spacing[0] },
                { label: 'Vertical', value: data.info.spacing[1] }
            ], infoDictionary.spacing);
            infoElement.appendChild(spacingEle);
            const stretchHEle = addInfo('stretchH', data.info.stretchH, infoDictionary.stretchH);
            infoElement.appendChild(stretchHEle);
            const unicodeEle = addInfo('unicode', data.info.unicode, infoDictionary.unicode);
            infoElement.appendChild(unicodeEle);
            const smoothEle = addInfo('smooth', data.info.smooth, infoDictionary.smooth);
            infoElement.appendChild(smoothEle);
            const aaEle = addInfo('aa', data.info.aa, infoDictionary.aa);
            infoElement.appendChild(aaEle);
            const outlineEle = addInfo('outline', data.info.outline, infoDictionary.outline);
            infoElement.appendChild(outlineEle);
        }
        const commonDictionary = {
            lineHeight: 'This is the distance in pixels between each line of text.',
            base: 'The number of pixels from the absolute top of the line to the base of the characters.',
            scaleW: 'The width of the texture, normally used to scale the x pos of the character image.',
            scaleH: 'The height of the texture, normally used to scale the y pos of the character image.',
            pages: 'The number of texture pages included in the font.',
            packed: 'Set to 1 if the monochrome characters have been packed into each of the texture channels. In this case alphaChnl describes what is stored in each channel.',
            alphaChnl: 'Set to 0 if the channel holds the glyph data, 1 if it holds the outline, 2 if it holds the glyph and the outline, 3 if its set to zero, and 4 if its set to one.',
            redChnl: 'Set to 0 if the channel holds the glyph data, 1 if it holds the outline, 2 if it holds the glyph and the outline, 3 if its set to zero, and 4 if its set to one.',
            greenChnl: 'Set to 0 if the channel holds the glyph data, 1 if it holds the outline, 2 if it holds the glyph and the outline, 3 if its set to zero, and 4 if its set to one.',
            blueChnl: 'Set to 0 if the channel holds the glyph data, 1 if it holds the outline, 2 if it holds the glyph and the outline, 3 if its set to zero, and 4 if its set to one.'
        };
        function updateCommon(data) {
            const commonElement = document.getElementById('common');
            Object.keys(commonDictionary).forEach(key => {
                const ele = addInfo(key, data.common[key], commonDictionary[key]);
                commonElement.appendChild(ele);
            });
        }
        function updateKernings(data) {
            const kerningsElement = document.getElementById('kernings');
            const ele = addInfo('Total Pairs', data.kernings.length, 'Total kerning pairs across all pages.');
            kerningsElement.appendChild(ele);
        }
        function drawCharacters(parentEle, chars) {
            chars.forEach(char => {
                const box = document.createElement('div');
                box.style.left = `${char.x * 2}px`;
                box.style.top = `${char.y * 2}px`;
                box.style.width = `${char.width * 2}px`;
                box.style.height = `${char.height * 2}px`;
                box.title = `id: ${char.id}`;
                parentEle.appendChild(box);
                characters.set(char.id, char);
                box.addEventListener('click', () => {
                    const textarea = document.querySelector('textarea');
                    textarea.value += String.fromCharCode(char.id);
                    const preview = document.querySelector('.preview');
                    updateText(preview, textarea.value);
                });
            });
            console.log(`Parsed ${chars.length} characters`);
        }
        function whiteToTransparent(ctx, width, height) {
            for (let x = 0; x < width; x++) {
                for (let y = 0; y < height; y++) {
                    const color = ctx.getImageData(x, y, 1, 1).data;
                    const [r, g, b] = color;
                    if (r === 255 && g === 255 && b === 255) {
                        ctx.clearRect(x, y, 1, 1);
                    }
                }
            }
        }
        const ToastTheme = {
            info: 'info',
            warning: 'warning',
            error: 'error',
            success: 'success'
        }
        function toast(message, theme) {
            const toast = document.createElement('div');
            toast.classList.add('toast');
            toast.classList.add(`toast-${theme || ToastTheme.info}`);
            toast.textContent = message;
            document.body.appendChild(toast);
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }
        function getCharKerning(previousCode, code) {
            const exists = kernings.has(`${previousCode}:${code}`);
            const amount = kernings.get(`${previousCode}:${code}`) || 0;
            return amount;
        }
        function getPairingEstimate(char1Code, char2Code) {
            // Scan left/right a max pixel width
            const maxScan = 10;
            const exists = kernings.has(`${char1Code}:${char2Code}`);
            const amount = kernings.get(`${char1Code}:${char2Code}`) || 0;
            const char1 = characters.get(char1Code);
            const char2 = characters.get(char2Code);
            const ele = document.createElement('canvas');
            const ctx = ele.getContext('2d', { willReadFrequently: true });
            ele.width = char1.width + char2.width;
            ele.height = Math.max(char1.height, char2.height);
            ele.style.width = `${ele.width}px`;
            ele.style.height = `${ele.height}px`;
            ctx.clearRect(0, 0, ele.width, ele.height);
            ctx.drawImage(
                imagePages.get(char1.page),
                char1.x, char1.y, char1.width, char1.height,
                0, 0, char1.width, char1.height
            );
            ctx.drawImage(
                imagePages.get(char2.page),
                char2.x, char2.y, char2.width, char2.height,
                char1.width, 0, char2.width, char2.height
            );
            // 1. loop height
            // 2. loop left
            // 3. loop right
            // 4. add left and right
            // 5. find lowest value
            const debugSpacing = [];
            let kern = 99;
            for (let h = 0; h < ele.height; h++) {
                let left = maxScan;
                for (let i = 1; i <= Math.min(char1.width, maxScan); i++) {
                    // Above, this prevents incorrect overhangs
                    if (h !== 0) {
                        const color = ctx.getImageData(char1.width - i, h - 1, 1, 1).data;
                        const [r, g, b] = color;
                        if (r === 0 && g === 0 && b === 0) {
                            left = i - 1;
                            break;
                        }
                    }
                    // Center
                    const color = ctx.getImageData(char1.width - i, h, 1, 1).data;
                    const [r, g, b] = color;
                    if (r === 0 && g === 0 && b === 0) {
                        left = i - 1;
                        break;
                    }
                    // Below, this prevents incorrect underhangs
                    if (h !== ele.height - 1) {
                        const color = ctx.getImageData(char1.width - i, h + 1, 1, 1).data;
                        const [r, g, b] = color;
                        if (r === 0 && g === 0 && b === 0) {
                            left = i - 1;
                            break;
                        }
                    }
                }
                let right = maxScan;
                for (let i = 0; i < Math.min(char2.width, maxScan); i++) {
                    // Above, this prevents incorrect overhangs
                    if (h !== 0) {
                        const color = ctx.getImageData(char1.width + i, h - 1, 1, 1).data;
                        const [r, g, b] = color;
                        if (r === 0 && g === 0 && b === 0) {
                            right = i;
                            break;
                        }
                    }
                    // Center
                    const color = ctx.getImageData(char1.width + i, h, 1, 1).data;
                    const [r, g, b] = color;
                    if (r === 0 && g === 0 && b === 0) {
                        right = i;
                        break;
                    }
                    // Below, this prevents incorrect underhangs
                    if (h !== ele.height - 1) {
                        const color = ctx.getImageData(char1.width + i, h + 1, 1, 1).data;
                        const [r, g, b] = color;
                        if (r === 0 && g === 0 && b === 0) {
                            right = i;
                            break;
                        }
                    }
                }
                debugSpacing.push([left, right]);
                kern = Math.min(kern, left + right);
            }
            return kern === 0 ? 0 : kern * -1;
        }
        function renderChar(parent, previousCode, code, kern = null) {
            const exists = kernings.has(`${previousCode}:${code}`);
            const amount = kernings.get(`${previousCode}:${code}`) || 0;
            const meta = characters.get(code);
            const ele = document.createElement('canvas');
            const ctx = ele.getContext('2d', { willReadFrequently: true });
            ele.width = meta.width;
            ele.height = meta.height;
            ele.style.width = `${meta.width}px`;
            ele.style.height = `${meta.height}px`;
            ctx.clearRect(0, 0, meta.width, meta.height);
            ctx.drawImage(
                imagePages.get(meta.page),
                meta.x, meta.y, meta.width, meta.height,
                0, 0, meta.width, meta.height
            );
            whiteToTransparent(ctx, meta.width, meta.height);
            // Default spacing
            let spaceHorizontal = info.get('spacing')[0];
            spaceHorizontal += kern === null ? amount : kern;
            let spaceVertical = info.get('spacing')[1];
            ele.style.marginLeft = `${spaceHorizontal}px`;
            ele.title = `kerning: ${spaceHorizontal}; ${code} (${previousCode})`;
            ele.addEventListener('mouseenter', () => {
                ele.classList.add(exists ? 'hover-exists' : 'hover');
            });
            ele.addEventListener('mouseleave', () => {
                ele.classList.remove(exists ? 'hover-exists' : 'hover');
            });
            ele.addEventListener('click', () => {
                if (exists) {
                    toast('Kerning pair exists aleady!', ToastTheme.warning);
                } else if (previousCode === null) {
                    toast('Previous char required for kerning.', ToastTheme.warning);
                } else {
                    copyToClipboard(`,\n        {\n            "first": ${previousCode},\n            "second": ${code},\n            "amount": -1\n        }`);
                }
            });
            parent.appendChild(ele);
        }
        function updateText(preview, text) {
            // Clear preview
            while(preview.firstChild){
                preview.removeChild(preview.firstChild);
            }
            // Insert
            let previousCode = null;
            text.split('').forEach(char => {
                if (char === '\n') {
                    const br = document.createElement('div');
                    br.classList.add('break');
                    preview.appendChild(br);
                    return;
                }
                const code = char.charCodeAt(0);
                renderChar(preview, previousCode, code);
                previousCode = code;
            });
        }
        function validate(data) {
            const errors = [];
            // No duplicates
            
            // Output
            if (errors.length) {
                errors.forEach(error => {
                    console.log(error);
                });
                return;
            }
            console.log('Completed, no errors.')
        }
        function process(data) {
            Object.keys(data.info).forEach(key => {
                info.set(key, data.info[key]);
            });
            updateInfo(data);
            console.log(`Parsed info`);
            updateCommon(data);
            updateKernings(data);
            console.log(`Parsed common`);
            data.pages.forEach((page, pageIndex) => {
                pages.set(pageIndex, page);
                pageIndexByName.set(page, pageIndex);
                addPage(page);
                const parentEle = document.createElement('div');
                parentEle.classList.add('page');
                const img = document.createElement('img');
                const size = document.createElement('span');
                img.addEventListener('load', (e) => {
                    const origionalWidth = img.width;
                    const origionalHeight = img.height;
                    const imgWidth = origionalWidth * 2;
                    e.target.style.width = `${imgWidth}px`;
                    parentEle.style.width = `${imgWidth}px`;
                    img.style.width = `${imgWidth}px`;
                    size.textContent = `${origionalWidth} x ${origionalHeight}`;
                });
                img.src = page;
                parentEle.appendChild(img);
                parentEle.appendChild(size);
                drawCharacters(
                    parentEle,
                    data.chars.filter(char => char.page === pageIndex)
                );
                document.querySelector('.main').appendChild(parentEle);
            });
            // Kerning Testing
            const preview = document.createElement('div');
            preview.classList.add('preview');
            const textarea = document.createElement('textarea');
            textarea.placeholder = 'Preview';
            textarea.addEventListener('input', (e) => {
                const { value } = e.target;
                updateText(preview, value);
                localStorage.setItem(`${file}:value`, value);
            });
            const tValue = localStorage.getItem(`${file}:value`);
            if (tValue) {
                textarea.value = tValue;
                // Need the kerning table before rendering
                requestAnimationFrame(() => {
                    updateText(preview, tValue);
                });
            }
            // Textarea
            document.querySelector('.main').appendChild(textarea);
            // Preview
            document.querySelector('.main').appendChild(preview);
            // Documentation
            const docs = document.createElement('div');
            docs.classList.add('doc');
            updateDocs(docs);
            document.querySelector('.main').appendChild(docs);
            // Select initial page
            const currentPage = localStorage.getItem(file);
            if (currentPage && pageIndexByName.has(currentPage)) {
                selectPage(currentPage);
            } else {
                selectPage(pages.get(0));
            }
            // Render Kerning Info
            const scroll = document.createElement('div');
            scroll.classList.add('kernings');
            scroll.addEventListener('scroll', (e) => {
                localStorage.setItem(`${file}:kernings`, e.target.scrollTop);
            });
            const table = document.createElement('table');
            const thTr = document.createElement('tr');
            const th1 = document.createElement('th');
            th1.textContent = 'First';
            const th2 = document.createElement('th');
            th2.textContent = 'Second';
            const th3 = document.createElement('th');
            th3.textContent = 'Amount';
            const th4 = document.createElement('th');
            th4.textContent = 'Preview';
            thTr.appendChild(th1);
            thTr.appendChild(th2);
            thTr.appendChild(th3);
            thTr.appendChild(th4);
            table.appendChild(thTr);
            scroll.appendChild(table);
            document.querySelector('.main').appendChild(scroll);
            data.kernings.forEach((kern, pageIndex) => {
                const { first, second, amount } = kern;
                if (kernings.has(`${first}:${second}`)) {
                    throw new Error(`Duplicate kerning pair: ${first} ${second}`);
                }
                kernings.set(`${first}:${second}`, amount);
                // Add to Chart
                const tdTr = document.createElement('tr');
                const td1 = document.createElement('td');
                td1.textContent = String.fromCharCode(first);
                const td2 = document.createElement('td');
                td2.textContent = String.fromCharCode(second);
                const td3 = document.createElement('td');
                td3.textContent = amount;
                const td4 = document.createElement('td');
                renderChar(td4, null, first);
                renderChar(td4, first, second);
                tdTr.appendChild(td1);
                tdTr.appendChild(td2);
                tdTr.appendChild(td3);
                tdTr.appendChild(td4);
                table.appendChild(tdTr);
            });
            console.log(`Parsed ${data.kernings.length} kerning pairs`);
            validate(data);
            // Reset Scroll Position
            const scrollPosition = localStorage.getItem(`${file}:kernings`);
            if (scrollPosition) {
                scroll.scrollTop = scrollPosition;
            }
        }
        function updateDocs(docs) {
            const p = (message) => {
                const ele = document.createElement('p');
                ele.appendChild(document.createTextNode(message));
                docs.appendChild(ele);
            };
            const list = (items) => {
                const ele = document.createElement('ul');
                items.forEach(item => {
                    const li = document.createElement('li');
                    li.textContent = item;
                    ele.appendChild(li);
                });
                docs.appendChild(ele);
            };
            const h2 = (header) => {
                const ele = document.createElement('h2');
                ele.appendChild(document.createTextNode(header));
                docs.appendChild(ele);
            };
            p('Update the json file and refresh to see changes.');
            h2('Features');
            list([
                'Validates json for common mistakes.',
                'Loops all common latin pairs for possible missing kerning pairs.'
            ]);
        }
        function copyToClipboard(text) {
            navigator.permissions.query({ name: "clipboard-write" }).then((result) => {
                if (result.state === "granted" || result.state === "prompt") {
                    navigator.clipboard.writeText(text).then(() => {
                        toast('Copied to clipboard!', ToastTheme.success);
                        console.log('Successfully wrote to clipboard');
                    }, () => {
                        console.error('Failed to write to clipboard');
                    });
                }
            });
        }
        // Note each new pair adds to initial load, so careful!!!
        const kerningCodes = [
            // Latin a-z A-Z
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74,
            75,
            76,
            77,
            78,
            79,
            80,
            81,
            82,
            83,
            84,
            85,
            86,
            87,
            88,
            89,
            90,
            97,
            98,
            99,
            100,
            101,
            102,
            103,
            104,
            105,
            106,
            107,
            108,
            109,
            110,
            111,
            112,
            113,
            114,
            115,
            116,
            117,
            118,
            119,
            120,
            121,
            122,
            // Symbols
            34, // "

            47, // /
            63, // ?
            92, // \
            94, // ^
            95, // _
            126, // ~
        ];
        // Cache
        let isKerningListCached = false;
        const kerningList = new Map();
        /**
         * Generate array with all kerning pairs and estimate.
         * 
         * If configured kerning is different than estimate add
         * a warning.
         * 
         * Map previousCode:code { estimate, actual }
         */
        function estimateKerningPairs() {
            if (isKerningListCached) {
                return kerningList;
            }
            isKerningListCached = true;
            const reversed = kerningCodes.toReversed();
            kerningCodes.forEach(char1 => {
                reversed.forEach(char2 => {
                    kerningList.set(`${char1}:${char2}`, {
                        estimate: getPairingEstimate(char1, char2),
                        actual: getCharKerning(char1, char2)
                    });
                });
            });
            return kerningList;
        }
        function selectFileTab() {
            document.getElementById('mainTabContent').classList.add('selected');
            document.getElementById('kernTabContent').classList.remove('selected');
            document.getElementById('mainTab').classList.add('selected');
            document.getElementById('kernTab').classList.remove('selected');
        }
        function selectKerningTab() {
            const kernTabContent = document.getElementById('kernTabContent');
            document.getElementById('mainTabContent').classList.remove('selected');
            kernTabContent.classList.add('selected');
            document.getElementById('mainTab').classList.remove('selected');
            document.getElementById('kernTab').classList.add('selected');
            if (isKerningListCached) {
                return;
            }
            const pairs = estimateKerningPairs();
            let ignoredPairs = 0;
            let existingPairs = 0;
            const newPairs = new Map();
            pairs.forEach((pair, key) => {
                if (kernings.has(key)) {
                    existingPairs++;
                    return;
                } else if (pair.estimate === 0) {
                    ignoredPairs++;
                    return;
                }
                newPairs.set(key, pair);
                //console.log(key, kernings.has(key), pair);
            });
            const infoEle = document.createElement('div');
            infoEle.classList.add('info');
            infoEle.textContent = `Potential Pairs: ${newPairs.size}; IgnoredPairs: ${ignoredPairs}; Existing Pairs: ${existingPairs}`;
            kernTabContent.appendChild(infoEle);
            const table = document.createElement('table');
            table.style.margin = '1rem';
            newPairs.forEach((pair, key) => {
                const tr = document.createElement('tr');
                const tds = [
                    [document.createElement('td'), ''],
                    [document.createElement('td'), ''],
                    [document.createElement('td'), ''],
                    [document.createElement('td'), ''],
                    [document.createElement('td'), ''],
                    [document.createElement('td'), ''],
                    [document.createElement('td'), ''],
                    [document.createElement('td'), ''],
                    [document.createElement('td'), '']
                ];
                const chars = key.split(':');
                const char1 = String.fromCharCode(chars[0]);
                const char2 = String.fromCharCode(chars[1]);
                tds[0][1] = key;
                tds[1][1] = pair.estimate;
                tds[2][1] = char1;
                tds[3][1] = char2;
                // Preview 0
                renderChar(tds[4][0], null, parseInt(chars[0], 10), 0);
                renderChar(tds[4][0], parseInt(chars[0], 10), parseInt(chars[1], 10), 0);
                // Preview -1
                renderChar(tds[5][0], null, parseInt(chars[0], 10), 0);
                renderChar(tds[5][0], parseInt(chars[0], 10), parseInt(chars[1], 10), -1);
                if (pair.estimate === -1) { tds[5][0].style.background = '#8de558'; }
                // Preview -2
                renderChar(tds[6][0], null, parseInt(chars[0], 10), 0);
                renderChar(tds[6][0], parseInt(chars[0], 10), parseInt(chars[1], 10), -2);
                if (pair.estimate === -2) { tds[6][0].style.background = '#8de558'; }
                // Preview -3
                renderChar(tds[7][0], null, parseInt(chars[0], 10), 0);
                renderChar(tds[7][0], parseInt(chars[0], 10), parseInt(chars[1], 10), -3);
                if (pair.estimate === -3) { tds[7][0].style.background = '#8de558'; }
                // Preview -4
                renderChar(tds[8][0], null, parseInt(chars[0], 10), 0);
                renderChar(tds[8][0], parseInt(chars[0], 10), parseInt(chars[1], 10), -4);
                if (pair.estimate === -4) { tds[8][0].style.background = '#8de558'; }
                tds.forEach(([td, value]) => {
                    if (value) {
                        td.textContent = value;
                    }
                    td.style.whiteSpace = 'nowrap';
                    tr.appendChild(td);
                });
                table.appendChild(tr);
            });
            kernTabContent.appendChild(table);
        }
        window.addEventListener('load', () => {
            console.log(`Loading '${file}'...`);
            document.getElementById('file').textContent = file;
            fetch(file, {
                method: 'GET',
                cache: "no-store"
            }).then(async (response) => {
                const json = await response.json();
                // We need all the image data also cached...
                const promises = [];
                json.pages.forEach((page, pageIndex) => {
                    const img = new Image();
                    promises.push(new Promise(resolve => {
                        img.addEventListener('load', () => {
                            resolve(img);
                        }); 
                    }));
                    console.log(`Loading '${page}'...`);
                    img.src = page;
                    imagePages.set(pageIndex, img);
                });
                Promise.all(promises).then(() => {
                    console.log(`Begin processing...`);
                    process(json);
                });
            });
            document.getElementById('reload').addEventListener('click', () => {
                window.location.reload();
            });
            document.getElementById('file').addEventListener('click', () => {
                selectFileTab();
            });
            document.getElementById('estimateKerning').addEventListener('click', () => {
                selectKerningTab();
            });
        });
    </script>
</head>
<body>
    <div class="header">
        <h1><span>BM</span> Bitmap Font Preview</h1>
    </div>
    <div class="links">
        <div class="tab selected" id="mainTab">
            <button id="file">Loading...</button>
        </div>
        <div class="tab" id="kernTab">
            <button id="estimateKerning" title="Processor intensive! May lag browser depending on latin characters in font.">Estimate Kerning</button>
        </div>
        <div>
            <a href="https://github.com/Templarian/">View on GitHub</a>
        </div>
    </div>
    <div class="tree">
        <ul>
            <li>
                <button title="Reload" id="reload">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="currentColor" d="M17.65,6.35C16.2,4.9 14.21,4 12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20C15.73,20 18.84,17.45 19.73,14H17.65C16.83,16.33 14.61,18 12,18A6,6 0 0,1 6,12A6,6 0 0,1 12,6C13.66,6 15.14,6.69 16.22,7.78L13,11H20V4L17.65,6.35Z" /></svg>
                    <span>Reload JSON</span>
                </button>
            </li>
            <li>
                <div>Pages</div>
                <ul id="pages" class="pages"></ul>
            </li>
            <li>
                <div>Font Info</div>
                <ul id="info" class="info"></ul>
            </li>
            <li>
                <div>Common</div>
                <ul id="common" class="common"></ul>
            </li>
            <li>
                <div>Kerning Pairs</div>
                <ul id="kernings" class="kernings"></ul>
            </li>
            <li class="appInfo">
                Version 0.5
            </li>
        </ul>
    </div>
    <div class="main selected" id="mainTabContent">
        
    </div>
    <div class="main" id="kernTabContent">
        
    </div>
</body>
</html>